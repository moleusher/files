% Ullmann Algorithm
function [r,m]=subgraph2(a,b)


%Ullmann算法:子图同构算法中最简单的一种
%判断图b中是否有子图同构于a
%a和b是图的邻接布尔矩阵
%返回0代表没有找到,1代表找到了.


%p1和p2代表a和b的阶
    [p1,tmp]=size(a);
    [p2,tmp]=size(b);
    %ab必须都是方阵
    %p1<=p2
    
%d是degree的意思
%用来存储每个顶点的度
    da=sum(a);
    db=sum(b);
    %对角线假定都是0
    %a,b必须对称
    
%m是a与b的关联矩阵 
%这是一个p1*p2的布尔矩阵
%其元素m(i,j)表示a的第i个节点和b的第j个节点是否对应
%因此这个矩阵的限制为：
    %每行有且只有一个1，而每列最多只有一个1 。
%我们把上面这个条件记作条件(0). 
%下面对m进行初始化
    m=zeros(p1,p2);
    for j=1:p2
        for i=1:p1
            %如果b的第j个节点的度>=a的第i个节点的度
            %表示可能匹配但是不一定
            if db(j)>=da(i)
                m(i,j)=1;
            end
            %此原则是针对无向图
        end
    end   
%如果m的某一行都是0,那么肯定没有同构子图.
    for i=1:p1
        if max(abs(m(i,:)))==0
            r=0;return
        end
    end
    
%使用一个大小为p2的布尔向量F来表示哪一列被使用了。
%比如F[2]==1表示在搜索中第二列被使用了,因为M的每列最多只
%有一个1,所以之后的搜索中都不要再考虑b中的第2个顶点了.    
    F=zeros(p2,1);
    
%使用一个大小为p1的向量H来表示在哪一层使用了哪一列。
%比如H[d] = k表示在层d中使用了第k列,
%也就是说a的第d个顶点对应于b的第k个顶点。
    H=zeros(p1,1);
    %如果H(d)=0代表着第d层还没有开始探索
    
%三维布尔矩阵matrixlist
%记录每层变化过的m
%保证回溯的时候可以回到上一层
    matrixlist=zeros([size(m),p1]);
%第d层的m记录在matrixlist(:,:,d)中
    %注意这里跟C语言不一样:
    %本来Ullmann是用的matrixlist[d],
    %但是因为matlab存储矩阵是列优先,
    %所以用matrixlist(:,:,d)来存储.
    
%使用d来表示m中的行,使用k来表示m中的列.    
    d=1;
    k=1;
    
%变量初始化完毕,下面是具体的算法
%大概思路是这样的:
%先找到一个满足条件(0)的m
%再判断这个m是否满足条件(1)
%满足则代表找到了同构子图并返回1
%不满足则再找下一个满足条件(0)的m
%直到所有满足条件(0)的m都被穷举
%则代表没有满足条件(1)的m所以返回0
    while 1  
    %这个最大的循环是对d进行的
    %也就是m的行循环
    %目的是找到满足条件(0)的m
    %循环超过最后一行则代表找到了一个满足条件(0)的m
    %回溯超过最前一行则代表所有满足条件(0)的m都被穷举了
        
        if H(d)==0
            %如果是新的一行
            k=1;
            matrixlist(:,:,d)=m;
        else %H(d)~=0
            %如果是回溯的
            k=H(d)+1;
            F(H(d))=0;
            m=matrixlist(:,:,d);
        end
        
        %下面这个循环是对k进行的
        %也就是m的列循环
        %目的是为了找到第d行中的满足条件的列
        while k<=p2
            if m(d,k)==1&&F(k)==0
                break;
                %这样的列可能有很多
                %找到第一个满足条件的
                %然后就用break跳出列循环
                %后面的列会在回溯到这一行时继续
            end
            k=k+1;
        end
        if k==p2+1
            %如果第d行中没有满足条件的列
            %回溯到上一层    
            H(d)=0;d=d-1;
        else
            %如果第d行中找到满足条件的列
            %前进到下一层
            m(d,:)=zeros(1,p2);m(d,k)=1;
            H(d)=k;F(k)=1;d=d+1;
        end
        
        if d==0
            %回溯超过最前一行
            %即所有满足条件(0)的m都被穷举了
            %那么图b中没有图a的同构子图.
                r=0;return;
        end
        
        if d==p1+1 
            %循环超过最后一行
            %即找到了一个满足条件(0)的m
            
        %如果找到了一个满足条件(0)的m
        %即m中有p1个1且它们不同行也不同列
        %这代表着b中有p1个顶点与a的p1个顶点对应
        %b中这些顶点组成的子图记为c
        %用矩阵来表述就是c=m*b*m'(m'代表m的转置)
        %如果对任意i,j∈[1:p1],都满足当aij=1时,有cij=1
        %那么显然a是c的子图
        %以上即是条件(1) 
            c=m*b*m';
            tmp=1;
            for i=1:p1*p1
                if a(i)==1 && c(i)~=1
                    tmp=0;break;
                end
            end
            
            if tmp
                %如果满足条件(1)
                %返回1
                r=1;return;
            else
                %如果不满足条件(1)
                %回溯到最后一行
                d=p1;
            end            
        end
        
           
    end %大循环结束 
    
       
end %算法结束 